{-# LANGUAGE GHC2024 #-}
-- Implement the following functions.
-- When you're done, ghc -Wall -Werror HW1.hs should successfully compile.
--
-- Tells HLS to show warnings, and the file won't be compiled if there are any warnings, e.g.,
-- eval (-- >>>) won't work.
{-# OPTIONS_GHC -Wall -Werror #-}
-- Refines the above, allowing for unused imports.
{-# OPTIONS_GHC -Wno-unused-imports #-}

module HW1 where

-- These import statement ensures you aren't using any "advanced" functions and types, e.g., lists.
import Prelude (Bool (..), Eq (..), Foldable (sum), Int, Integer, Num (..), Ord (..), abs, div, error, even, flip, fst, id, mod, not, odd, otherwise, snd, take, undefined, ($), (&&), (.), (^), (||))

------------------------------------------------
-- DO NOT MODIFY ANYTHING ABOVE THIS LINE !!! --
------------------------------------------------

---------------------------------------------------
-- Section 1: Function Composition & Transformation
---------------------------------------------------

curry3 :: ((a, b, c) -> d) -> a -> b -> c -> d
curry3 f a b c = f (a, b, c)

uncurry3 :: (a -> b -> c -> d) -> (a, b, c) -> d
uncurry3 f (a, b, c) = f a b c

fst3 :: (a, b, c) -> a
fst3 (a, _, _) = a

snd3 :: (a, b, c) -> b
snd3 (_, b, _) = b

thd3 :: (a, b, c) -> c
thd3 (_, _, c) = c

dropFst :: (a, b, c) -> (b, c)
dropFst (_, b, c) = (b, c)

dropSnd :: (a, b, c) -> (a, c)
dropSnd (a, _, c) = (a, c)

dropThd :: (a, b, c) -> (a, b)
dropThd (a, b, _) = (a, b)

mapPair :: (a -> b) -> (a, a) -> (b, b)
mapPair f (x, y) = (f x, f y)

pairApply :: (a -> b) -> (a -> c) -> a -> (b, c)
pairApply f g a = (f a, g a)

const :: a -> b -> a
const a _ = a

constSecond :: a -> b -> b
constSecond _ b = b

const2 :: a -> b -> c -> a
const2 a _ _ = a 

-- Generatlizations of (.)
(.:) :: (c -> d) -> (a -> b -> c) -> a -> b -> d -- Hint: We saw this in class!
(.:) = (.) . (.)
(.:.) :: (d -> e) -> (a -> b -> c -> d) -> a -> b -> c -> e
(.:.) = (.) . (.:)
(.::) :: (e -> f) -> (a -> b -> c -> d -> e) -> a -> b -> c -> d -> f
(.::) = (.) . (.:.)
(.::.) :: (f -> g) -> (a -> b -> c -> d -> e -> f) -> a -> b -> c -> d -> e -> g
(.::.) = (.) . (.::)

-- How can we ever implement such a function!?
impossible :: a -> b
impossible _ = error "impossible to implement"

---------------------------------------------------
-- Section 2: Function Composition & Transformation
---------------------------------------------------
-- Count the number of digits of an integer
countDigits :: Integer -> Integer
countDigits n = case abs n of
    x | x >= 10 -> 1 + countDigits (x `div` 10)
    _ -> 1

-- Sums the  digits of an integer
sumDigits :: Integer -> Integer
sumDigits n = case abs n of
    0 -> 0
    x -> x `mod` 10 + sumDigits (x `div` 10)

-- Reverses the  digits of an integer
reverseDigits :: Integer -> Integer
reverseDigits n = case n of
    x | x > 0 -> (x `mod` 10) * 10 ^ (countDigits x - 1) + reverseDigits (x `div` 10)
    x | x < 0 -> -1 * reverseDigits (abs x)
    _ -> 0

-- Returns the length of the Collatz sequence starting from x. collatzLength 1 = 0. You can assume the input is positive.
collatzLength :: Integer -> Integer
collatzLength n = case n of
    1 -> 0
    x | x > 1 -> if even x then 1 + collatzLength (x `div` 2) else 1 + collatzLength (3 * x + 1)
    _ -> 0

------------------------
-- Section 3: Generators
------------------------

-- Type definition for a generator: a function producing a sequence of values
-- 1. The first function generates the next value.
-- 2. The second function checks if generation should continue.
-- 3. The third value is the initial value, or seed. It does not count as being generated by the generator.
type Generator a = (a -> a, a -> Bool, a)

-- Retrieves the nth value from a generator, or the last element. The seed does not count as an element.
-- If n is negative, return the seed.
nthGen :: Integer -> Generator a -> a
nthGen n (f, cond, seed) = case n of
    0 -> f seed
    x | x > 0 -> if cond seed then nthGen (x - 1) (f, cond, f seed) else seed
    _ -> seed

hasNext :: Generator a -> Bool
-- Behavior is undefined if the generator has stopped.
hasNext (_, cond, seed) = cond seed

nextGen :: Generator a -> Generator a
-- Will not terminate if the generator does not stop.
nextGen (f, cond, seed) = (f, cond, f seed)

lengthGen :: Generator a -> Integer
-- Should terminate for infinite generators as well.
lengthGen (f, cond, seed) = if cond seed then 1 + lengthGen (f, cond, f seed) else 0

hasLengthOfAtLeast :: Integer -> Generator a -> Bool
hasLengthOfAtLeast n (f, cond, seed) = case n of
    0 -> True
    x | x > 0 -> if cond seed then hasLengthOfAtLeast (x - 1) (f, cond, f seed) else False
    _ -> False

constGen :: a -> Generator a
constGen a = (const a, const True, a)

foreverGen :: (a -> a) -> a -> Generator a
foreverGen f a = (f, const True, a)

emptyGen :: Generator a
emptyGen = (undefined , const False, undefined)

-- Generates all integers except 0.
integers :: Generator Integer
integers = foreverGen f 0
    where 
        f :: Integer -> Integer
        f n = case n of -- generates all integers except 0 in an alternating pattern
            x | x <= 0 -> (-x) + 1
            x | x > 0 -> (-x)
            _ -> 0 -- not reachable

-- Sums all the values produced by a generator until it stops.
sumGen :: Generator Integer -> Integer
sumGen (f, cond, seed) = let nextSeed = f seed in 
                           if cond seed then nextSeed + sumGen (f, cond, nextSeed) 
                           else 0

-- Checks if a generator produces a value that satisfies a predicate.
anyGen :: (a -> Bool) -> Generator a -> Bool
anyGen p (f, cond, seed) = let nextSeed = f seed in
                             if not (cond seed) then False 
                             else if p nextSeed then True 
                             else anyGen p (f, cond, f seed)

-- Adds an additional predicate to a generator.
andAlso :: (a -> Bool) -> Generator a -> Generator a
andAlso p (f, cond, seed) = (f, \x -> p x && cond x, seed)

-- Bonus (15 points): Generates all positive divisors of a number smaller than the number itself.
divisors :: Integer -> Generator Integer
divisors n =
  case abs n of
    x | x <= 1 -> emptyGen
    x -> nextDivisor ((\y -> y /= 0 && y /= n && n `mod` y == 0)) ((+ 1), (< x), 0)
  where
    nextDivisor :: (a -> Bool) -> Generator a -> Generator a
    nextDivisor p (f, cond, seed) = (cont, pred, seed)
        where
            cont x = next (f x)

            pred = \x -> if cond (cont x) then p (cont x) else False

            next x = if cond x && not (p x) then next (f x) else x

-----------------------------------
-- Section 4: Number classification
-----------------------------------

isPrime :: Integer -> Bool
isPrime n
  | n < 2 = False
  | otherwise = not (hasDivisor 2)
  where
    hasDivisor :: Integer -> Bool
    hasDivisor d
      | d * d > n = False
      | n `mod` d == 0 = True
      | otherwise = hasDivisor (d + 1)

nextPrime :: Integer -> Integer
nextPrime n = let candidate = n + 1 in 
                  if isPrime candidate then candidate
                  else nextPrime candidate

primes :: Generator Integer
primes = foreverGen nextPrime 1

isHappy :: Integer -> Bool
isHappy n | n < 0 = isHappy (abs n)
isHappy n = checkLoop n $ sumSquareDigits n
    where
        sumSquareDigits :: Integer -> Integer
        sumSquareDigits x = case x of
            y | y < 0 -> sumSquareDigits (abs y)
            y | y < 10 -> y ^ (2 :: Integer)
            y -> sumSquareDigits (y `div` 10) + (y `mod` 10) ^ (2 :: Integer)
        checkLoop :: Integer -> Integer -> Bool
        checkLoop _ 1 = True
        checkLoop slow fast = 
            let slow' = sumSquareDigits slow
                fast' = sumSquareDigits (sumSquareDigits fast)
            in if slow' == fast' then False
               else checkLoop slow' fast'
        
isArmstrong :: Integer -> Bool
isArmstrong n = n >= 0 && sumKDigits n == n
    where 
        k = countDigits n
        sumKDigits :: Integer -> Integer
        sumKDigits 0 = 0
        sumKDigits x = (x `mod` 10) ^ k + sumKDigits (x `div` 10)

isPalindromicPrime :: Integer -> Bool
isPalindromicPrime n = isPrime n && reverseDigits n == n